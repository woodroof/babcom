# Соглашения
1. Во всех строках используется кодировка UTF-8.
2. Для работы с сервером используется только HTTPS.
3. Любые текстовые поля, предназначенные для отображения, могут содержать HTML.
4. Дата и время передаётся в формате YYYY-MM-DDTHH:MM:SS[.sss]Z (подмножество ISO 8601), т.е. в UTC.

# Web API
Есть ровно один фиксированный URL для всех действий с системой. Действия осуществляются только через метод *POST* и различаются только телом запроса. Данные отправляются без дополнительного кодирования, в запросах и ответах явно должен проставляться `Content-Type: application/json`.

## Коды ответов
* **200** — успешное выполнение запроса
* **400** — неправильный метод (не *POST*) или тело не является JSON-документом
* **500** — внутренняя ошибка

Код ответа **200** не означает успеха операции, его нужно определять по содержимому тела ответа.

## Тело запроса
	{
		"client": "<уникальный идентификатор клиента>",
		"function": "<имя выполняемой функции>",
		"params": {}
	}
Клиент однократно генерирует UUID v4, а затем при **каждом** обращении к серверу отправляет его в поле *client*.  
Имена функций, которые могут выполняться, а также описание их параметров описаны ниже в разделе *Функции*.

## Тело ответа
	{
		"result": "<результат работы функции>",
		"message": "<сообщение пользователю>",
		"data": <возвращаемые данные функции>
	}
Поле *result* содержит результат выполнения функции:

* **ok** — успешное выполнение функции
* **not modified** — запрошенные данные не изменились с указанного момента времени
* **bad request** — неправильные параметры запроса
* **forbidden** — пользователь не может выполнять действия от имени указанного объекта либо у пользователя нет прав на выполнение функции, доступной только администратору
* **not found** — запрошенные данные не найдены или недоступны объекту, от имени которого производится действие
* **internal server error** — внутренняя ошибка

Поле *message* может отсутствовать. Если оно присутствует, то в случае ошибки содержит её описание, а в случае успешного выполнения функции содержит сообщение, которое необходимо отобразить пользователю. Клиент не должен скрывать сообщения сам. Сообщения должны скрываться либо пользователем явно, либо при выполнении им какого-то действия.  
Поле *data* передаётся только в случае успешного выполнения функции (результат **ok**) и содержит возвращаемые данные функции.

# Пользовательские функции
## get\_features
Получение поддерживаемых возможностей (описаны в отдельных документах).

**params**:

	{
	}

**data**:

	[
		"<код поддерживаемой возможности>"
	]
Массив может быть пустым. Клиент может рассчитывать на то, что за время одной сессии список поддерживаемых возможностей не изменится.

## get\_user\_objects
Получение списка объектов, которыми пользователь может управлять.

**params**:

	{
		"if_modified_since": "<время последнего получения списка объектов, которыми может управлять пользователь>"
	}

**data**:

	{
		"last_modified": "<время последнего изменения списка объектов, которыми может управлять пользователь>",
		"objects": []
	}
Содержимое массива *objects* соответствует содержимому *objects* функции *get\_objects* с параметрами `"get_actions": false`, `"get_template": false`, `"attributes": ["name"]` и `"sort": [{"attribute_code": true, "type": "asc"}]`.  
Для получения изменений требуется использовать именно эту функцию, а не функцию *get\_objects*, т.к. время учитывает как изменение самих объектов, так и изменение самого списка.

## get\_objects
Получение списка объектов.

**params**:

	{
		"if_modified_since": "<время последнего получения указанных объектов с теми же параметрами>",
		"user_object_code": "<код объекта, от имени которого выполняется действие>",
		"object_codes": [
			"<код запрашиваемого объекта>",
			...
		],
		"attributes": [],
		"get_actions": <true/false>,
		"get_template": <true/false>,
		"filters": [
			{
				"type": "<тип фильтра>",
				"attribute_code": "<код атрибута>",
				"data": <специфические данные для указанного типа фильтра>
			},
			...
		],
		"sort": [
			{
				"attribute_code": "<код атрибута>",
				"type": "<тип сортировки>"
			},
			...
		],
		"limit": <количество объектов, которые требуется получить>
	}
Если передано поле *attributes*, возвращаются только атрибуты с указанными кодами. Некоторые атрибуты не возвращаются, если не указаны явно.  
Если поле *get\_actions* не указано или равно `null` или `true`, то в ответе возвращаются действия.  
Если поле *get\_template* не указано или равно `null` или `true`, то в ответе возвращается шаблон.  
Если поле *filters* указано, в результат попадут только объекты, соответствующие всем указанным условиям. Атрибуты, используемые в фильтрах, могут быть не указаны в поле *attributes* и, таким образом, могут не попасть в ответ.  
Известные типы фильтров:

* **code not in** — поле *attribute\_code* не передаётся, а в *data* содержится массив с кодами объектов, которые не должны попадать в результат.
* **mask** — *data* содержит строку с маской, где символ "%" используется для соответствия любому количеству любых символов, а "\_" обозначает любой одиночный символ. Если требуется в маске найти соответствие символам "%", "\_" и "\", перед ними нужно вставить дополнительный символ "\". Может применяться только к атрибутам со строковым значением.
* **lt**, **le**, **gt**, **ge** — операции `<`, `<=`, `>`, `>=`. Поле *data* содержит строковое или числовое значение, стоящее справа от указанной операции.
* **contains one of** — поле *data* содержит массив значений (возможно, массив из одного значения). Условие считается выполненным, если одно из значений в массиве *data* имеется в массиве значений атрибута.

Если тип значения атрибута не соответствует указанному фильтру (для операций сравнения типу поля *data*), условие считается не выполненным. Таким образом, наличие противоречивых фильтров, например, указание для одного атрибута одновременно фильтра **contains one of** и любого другого фильтра, будет приводить к пустому результату.  
Если поле *sort* указано, оно содержит список атрибутов с направлением сортировки. Сортировка всегда производится в порядке, указанном в запросе. В качестве последнего условия автоматически добавляется сортировка по увеличению кода объекта. Атрибуты, указанные в условиях сортировки, могут быть не указаны в поле *attributes* и, таким образом, могут не попасть в ответ.  
Допустимые типы сортировок:

* **asc** — по возрастанию значения.
* **desc** — по убыванию значения.

**data**:

	{
		"last_modified": "<время последнего изменения указанных атрибутов запрошенных объектов, их действий и/или шаблонов>",
		"objects": [
			{
				"code": "<код объекта>",
				"attributes": {
					"<код атрибута>": {
						"name": "<имя атрибута>",
						"value": <значение атрибута>,
						"value_description": "<описание значения атрибута>",
						"hidden": true
					},
					...
				},
				"actions": {
					"<код действия для шаблона>": {
						"code": "<код действия>",
						"name": "<имя действия для отображения>",
						"type": "<код типа действия>",
						"disabled": true,
						"warning": "<текст предупреждения>",
						"params": <значение>,
						"user_params": [
							{
								"code": "<код пользовательского параметра>",
								"type": "<тип параметра>",
								"data": <специфические для типа параметра данные>,
								"description": "<описание назначения параметра, вводимого пользователем при выполнении действия>",
								"default_value": <значение параметра по умолчанию>,
								"min_value_count": <минимальное количество значений в параметре>,
								"max_value_count": <максимальное количество значений в параметре>
							},
							...
						]
					},
					...
				},
				"template": {
					"groups": [
						{
							"name": "<имя группы для отображения>",
							"attributes": [],
							"actions": []
						},
						...
					]
				}
			}
		]
	}
Поле *last\_modified* не может использоваться в запросах с другими параметрами.  
Поле *attributes* может отсутствовать в случае, если у объекта нет доступных объекту пользователя атрибутов (вообще или среди перечисленных в поле *attributes* запроса).  
Код атрибута не должен отображаться клиентом и может использоваться только для кастомизации.  
Имя атрибута может отсутствовать.  
Значение поля *value* не должно отображаться клиентом и может использоваться только для кастомизации, за исключением случая, когда отсутствует поле *value\_description* и значение является числом, строкой или . Если поле *value* содержит массив или json-объект, а поле *value\_description* отсутствует, то либо атрибут не отображается (может быть использован только для кастомизации).  
Когда поле *hidden* присутствует, оно всегда равно `true`. Такие атрибуты не должны отображаться клиентом и могут использоваться только для кастомизации (например, для определения шаблона на основе типа отображаемого объекта).  
Поле *actions* отсутствует, если действий нет или если в запросе было передано поле *get\_actions* со значением `false`.  
Поле *type* нужно только для кастомизации на стороне клиента.  
Если поле *disabled* отсутствует, то действие можно выполнять. В противном случае значение всегда равно `true`, а поля *warning*, *params* и *user\_params* отсутствуют.  
Если поле *warning* присутствует, то перед непосредственным применением действия пользователю необходимо показать предупреждение и спросить, уверен ли он в том, что действительно хочет выполнить это действие.  
Поле *params* **не** разбирается клиентом и передаётся в неизменном виде в функцию *make\_action*.  
Поле *user\_params* содержит параметры, значения которых должны быть заданы пользователем. Если поле отсутствует, действие не требует ввода параметров. Если поле *default\_value* присутствует, оно содержит значение (или значения) по умолчанию, которые пользователь может изменить. Если поле *min\_value\_count* отсутствует, то считается, что оно равно `0` (параметр действия не является обязательным). Если поле присутствует, то оно содержит положительное число минимально допустимого количества значений параметра. Если поле *max\_value\_count* отсутствует, то максимальное количество значений параметра не ограничено. Если поле присутствует, то оно содержит положительное число максимально допустимого количества значений параметра, большее либо равное *min\_value\_count*.  
Известные типы параметров:

* **integer**: *data* может отсутствовать. Если присутствует, то содержит объект, в котором могут присутствовать ограничения на значение передаваемого числа в полях *min\_value* и *max\_value*.
* **float**: *data* может отсутствовать. Если присутствует, то содержит объект, в котором могут присутствовать ограничения на значение передаваемого числа в полях *min\_value* и *max\_value*.
* **string**: *data* может отсутствовать. Если присутствует, то содержит объект, в котором могут присутствовать ограничения на размер передаваемой строки в полях *min\_length* и *max\_length*, а также поле *multiline* со значением *true* для случаев, когда допускается ввод текста из нескольких строк.
* **objects**: *data* содержит объект с полями *object\_code* и *attribute\_code* (код объекта и код его атрибута, в котором хранятся коды объектов, из которых нужно выбрать один или несколько в качестве значения параметра). Для отображения в списке нужно использовать атрибут *name* объектов списка.

Поле *template* отсутствует, если шаблон для объекта не найден или в запросе было поле *get\_template* со значением `false`. Поле содержит описание отображения объекта, которое используется в случае, когда клиент не использует свой шаблон для данного объекта. В заголовке отображается содержимое атрибута *name*. Клиент должен корректно обрабатывать ситуацию, когда атрибут *name* отсутствует. Остальные атрибуты разбиваются на группы. Каждая группа имеет заголовок, затем отображаются атрибуты в порядке следования их кодов в поле *attributes*, затем идут действия группы в порядке следования их кодов в поле *actions*. Поля *attributes* и *actions* могут отсутствовать. Если поле *name* группы отсутствует, группа не имеет заголовка. Если клиент не использует для объекта свой шаблон и стандартный шаблон не найден, в заголовок выносится атрибут *name*, остальные атрибуты отображаются в порядке лексикографической сортировки их кодов, а в самом конце отображаются действия (тоже в порядке лексикографической сортировки кодов).

## get\_objects
Получение списка объектов, заданного в атрибуте указанного объекта.

**params**:

	{
		"if_modified_since": "<время последнего получения указанных объектов с теми же параметрами>",
		"user_object_code": "<код объекта, от имени которого выполняется действие>",
		"object_code": "<код объекта, содержащего атрибут со списком кодов объектов>",
		"attribute_code": "<код атрибута, содержащего список кодов объектов>",
		"attributes": [],
		"get_actions": <true/false>,
		"get_template": <true/false>,
		"filters": [
			{
				"type": "<тип фильтра>",
				"attribute_code": "<код атрибута>",
				"data": <специфические данные для указанного типа фильтра>
			},
			...
		],
		"sort": [
			{
				"attribute_code": "<код атрибута>",
				"type": "<тип сортировки>"
			},
			...
		],
		"limit": <количество объектов, которые требуется получить>
	}

**data**:

	{
	}
Ответ полностью совпадает с ответом функции *get\_objects*, принимающей на вход список кодов объектов.

## get\_objects\_changes
Получение изменений указанного списка объектов.

**params**:

	{
		"if_modified_since": "<время последнего получения изменений с теми же параметрами>",
		"user_object_code": "<код объекта, от имени которого выполняется действие>",
		"object_codes": [
			"<код запрашиваемого объекта>",
			...
		],
		"attributes": []
	}
Если поле *if\_modified\_since* отсутствует, возвращаются все объекты списка. Если поле присутствует, возвращаются только изменённые атрибуты и объекты. При отсутствии изменений поле *result* будет содержать **not modified**.  
Если передано поле *attributes*, возвращаются только атрибуты с указанными кодами. Некоторые атрибуты не возвращаются, если не указаны явно.

**data**:

	{
		"last_modified": "<время последнего изменения одного из указанных атрибутов запрошенных объектов>",
		"changes": {
			"<код изменённого объекта>": null | {
				"<код изменённого объекта>": null | <значение атрибута>,
				...
			},
			...
		}
	}
Если объект был удалён, то его коду в ответе будет соответствовать значение `null`. Коду объекта может соответствовать пустой JSON-объект, например, когда у объекта нет ни одного из атрибутов, указанных в поле *attributes* запроса.  
Если атрибут был удалён, то его коду в ответе будет соответствовать значение `null`.

## get\_objects\_changes
Получение изменений указанных объектов.

**params**:

	{
		"if_modified_since": "<время последнего получения изменений с теми же параметрами>",
		"user_object_code": "<код объекта, от имени которого выполняется действие>",
		"object_code": "<код объекта, содержащего атрибут со списком кодов объектов>",
		"attribute_code": "<код атрибута, содержащего список кодов объектов>",
		"attributes": []
	}

**data**:

	{
		"last_modified": "<время последнего изменения одного из указанных атрибутов запрошенных объектов>",
		"changes": {
			"<код изменённого объекта>": null | {
				"<код изменённого объекта>": null | <значение атрибута>,
				...
			},
			...
		}
	}
Ответ полностью совпадает с ответом функции *get\_objects\_changes*, принимающей на вход список кодов объектов.

## make\_action
Выполнение действия.

**params**:

	{
		"user_object_code": "<код объекта, от имени которого выполняется действие>",
		"action_code": "<код действия>",
		"params": {},
		"user_params": {
			"<код пользовательского параметра>": <значение пользовательского параметра>,
			...
		}
	}
Значение пользовательского параметра содержит элемент или массив (в случае нескольких значений). JSON-тип элемента (элементов массива) зависит от типа действия: `number` для **integer** или **float**, `string` для других типов.

**data**:

	null | {}
Если поле *data* равно `null`, то клиент должен перейти на основной экран (например, объект пользователя). В противном случае значение полностью совпадает с ответом функции *get\_objects* (в ответе всегда будет только один объект). Если возвращается тот же объект, что отображался до осуществления действия, то клиент должен попытаться отобразить на экране те же атрибуты в тех же местах, где они отображались до выполнения действия.

## get\_notifications
Получение списка уведомлений.

**params**:

	{
		"if_modified_since": "<время последнего получения изменений списка уведомлений>"
	}
Если поле *if\_modified\_since* отсутствует, возвращаются все уведомления.

**data**:

	{
		"last_modified": "<время последнего изменения списка уведомлений>",
		"notifications": [
			{
				"send_time": "<дата и время отправки уведомления>",
				"text": "<текст уведомления>",
				"object_code": <код привязанного объекта>,
				"changed_objects": [
					<код изменившегося объекта>,
					...
				]
			}
		]
	}
Возвращаемые данные упорядочены по возрастанию *send\_time*.  
Если клиент отображает один из указанных в *changed\_objects* объектов, он должен его немедленно обновить.

# Функции для администратора
Будут добавлены позже.

# FAQ
* Допускается ли работа без аутентификации?  
Если имеется сессия с пустым кодом, то при отсутствии связи содержимого поля *client* c пользователем будет создана связь с пользователем этой сессии (анонимным пользователем). Можно запретить работу клиентов без явно прописанных разрешений, удалив сессию с пустым кодом.

* Как будет происходить аутентификация, если у нас нет такой функции?  
Есть два способа. Первый — попробовать получить специальный объект (например, через QR-коды), после чего для значения, указанного в поле *client*, будет сохранена привязка к пользователю. Второй — в одном из объектов, доступных анонимному пользователю, будет действие, принимающее авторизационный код.

* Что должно быть в QR-кодах?  
Предлагается хранить только код объекта вместо полноценной ссылки. Это позволит минимизировать объём данных и упростить QR-код, а более простые QR-коды легче распознаются.

* Как отображать список для выбора объекта/объектов, необходимых для заполнения пользовательского параметра действия?  
В общем случае при заполнении такого параметра нужно показывать пользователю фильтр по атрибуту *name*, отправлять запрос при изменении поля на получение ограниченного количества объектов с параметром `"attributes": ["name"]` и сортировкой по атрибуту *name* и показывать получаемые результаты. После выбора пользователем одного из отображаемых объектов нужно выбирать/добавлять значение в список параметров и убирать такие объекты из списка (отправлять фильтр с типом **code not in**).  
В случае, если клиент обрабатывает действия с какими-то кодами особым образом, может иметь смысл как получать список целиком, так и получать дополнительные атрибуты или сортировать по другим условиям.

* Как проверять наличие новых уведомлений или изменение списка объектов, которыми может управлять пользователь?  
Рекомендуется после отправки любого запроса на выполнение действия, а также получение объекта или списка объектов, отправлять дополнительные запросы на проверку наличия изменений в списке уведомлений, а также в списке объектов, которыми может управлять пользователь. Для минимизации времени ожидания рекомендуется передавать эти запросы сразу же и использовать для этого одно подключение.
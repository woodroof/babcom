# Соглашения
1. Во всех строках используется кодировка UTF-8.
2. Для работы с сервером используется только HTTPS.
3. Любые текстовые поля, предназначенные для отображения, могут содержать HTML.
4. Ссылки, ведущие на объекты системы, содержат href вида `babcom:<код объекта>`.
5. Дата и время передаётся в формате YYYY-MM-DDTHH:MM:SS[.sss]Z (подмножество ISO 8601), т.е. в UTC.

# Web API
Есть ровно один фиксированный URL для всех действий с системой. Действия осуществляются только через метод *POST* и различаются только телом запроса. Данные отправляются без дополнительного кодирования, в запросах и ответах явно должен проставляться `Content-Type: application/json`.

## Коды ответов
* **200** — успешное выполнение запроса
* **304** — запрошенные данные не изменились с указанного момента времени
* **400** — тело не является JSON-документом либо содержимое JSON-документа не соответствует формату
* **403** — пользователь не может выполнять действия от имени указанного объекта либо у пользователя нет прав на выполнение функции, доступной только администратору
* **404** — запрошенные данные не найдены или недоступны объекту, от имени которого производится действие
* **405** — неправильный метод (не *POST*)
* **409** — предусловия генерации действия изменились, требуется повторный запрос действия объекта
* **415** — содержимое `Content-Type` отличается от "application/json"
* **500** — внутренняя ошибка

## Тело запроса
	{
		"client": "<уникальный идентификатор клиента>",
		"function": "<имя выполняемой функции>",
		"params": {}
	}
Клиент однократно генерирует UUID v4, а затем при **каждом** обращении к серверу отправляет его в поле *client*.  
Все функции выполняются от имени пользователя, привязанного к клиенту. Привязка создаётся автоматически для новых клиентов и может изменяться при выполнении действий.  
Имена функций, которые могут выполняться, а также описание их параметров описаны ниже в разделе *Функции*.

## Тело ответа
	{
		"message": "<сообщение пользователю>",
		"data": <возвращаемые данные функции>
	}
Поле *message* может отсутствовать. Если оно присутствует, то в случае ошибки содержит её описание, а в случае успешного выполнения функции (код ответа **200**) содержит сообщение, которое необходимо отобразить пользователю. Клиент не должен скрывать сообщения сам. Сообщения должны скрываться либо пользователем явно, либо при выполнении им какого-то действия.  
Поле *data* передаётся только в случае успешного выполнения функции и содержит её возвращаемые данные.

# Пользовательские функции
## get\_extensions
Получение списка активных расширений (описаны в отдельных документах).

**params**:

	{
	}

**data**:

	[
		"<код расширения>"
	]
Массив может быть пустым. Клиент может рассчитывать на то, что за время одной сессии список активных расширений не изменится.

## get\_user\_objects
Получение списка объектов, которыми пользователь может управлять.

**params**:

	{
		"if_non_match": "<метка, соответствующая последнему полученному списку объектов, которыми может управлять пользователь>"
	}

**data**:

	{
		"etag": "<метка, соответствующая текущему списку объектов, которыми может управлять пользователь>",
		"objects": []
	}
Содержимое массива *objects* соответствует содержимому *objects* функции *get\_objects* с параметрами `"get_actions": false`, `"get_templates": false`, `"attributes": ["name"]` и `"sort": [{"attribute_code": "name", "type": "asc"}]`.  
Для получения изменений требуется использовать именно эту функцию, а не функцию *get\_objects*, т.к. объекты получаются от имени их самих, а метка учитывает как изменение самих объектов, так и изменение самого списка (в том числе из-за изменения пользователя, привязанного к клиенту).

## get\_objects
Получение списка объектов.

**params**:

	{
		"if_non_match": "<метка, соответствующая последнему ответу на запрос с теми же параметрами>",
		"user_object_code": "<код объекта, от имени которого выполняется функция>",
		"object_code": "<код объекта, содержащего атрибут со списком кодов объектов>",
		"attribute_code": "<код атрибута, содержащего список кодов объектов>",
		"object_codes": [
			"<код запрашиваемого объекта>",
			...
		],
		"attributes": [],
		"get_actions": <true/false>,
		"get_templates": <true/false>,
		"filters": [
			{
				"type": "<тип фильтра>",
				"attribute_code": "<код атрибута>",
				"data": <специфические данные для указанного типа фильтра>
			},
			...
		],
		"sort": [
			{
				"attribute_code": "<код атрибута>",
				"type": "<тип сортировки>"
			},
			...
		],
		"limit": <количество объектов, которые требуется получить>
	}
Если передано поле *object\_codes*, то поля *object\_code* и *attribute\_code* обязаны отсутствовать.  
Если передано поле *attributes*, возвращаются только атрибуты с указанными кодами. Некоторые атрибуты не возвращаются, если не указаны явно.  
Если поле *get\_actions* не указано или равно `null` или `true`, то в ответе возвращаются действия.  
Если поле *get\_templates* не указано или равно `null` или `true`, то в ответе возвращается шаблон.  
Если поле *filters* указано, в результат попадут только объекты, соответствующие всем указанным условиям. Атрибуты, используемые в фильтрах, могут быть не указаны в поле *attributes* и, таким образом, могут не попасть в ответ.  
Известные типы фильтров:

* **code not in** — поле *attribute\_code* не передаётся, а в *data* содержится массив с кодами объектов, которые не должны попадать в результат.
* **after** — поле *attribute\_code* не передаётся, а в *data* содержится код объекта. Объекты, коды которых в **источнике** (поле *object\_codes* или в атрибуте *attribute\_code*) находятся до первого вхождения указанного кода включительно, пропускаются.  
* **mask** — *data* содержит строку с маской, где символ "%" используется для соответствия любому количеству любых символов, а "\_" обозначает любой одиночный символ. Если требуется в маске найти соответствие символам "%", "\_" и "\", перед ними нужно вставить дополнительный символ "\". Может применяться только к атрибутам со строковым значением.
* **lt**, **le**, **gt**, **ge**, **eq**, **ne** — операции `<`, `<=`, `>`, `>=`, `=`, `!=`. Поле *data* содержит строку или целое число, стоящее справа от указанной операции.
* **contains one of** — поле *data* содержит массив значений (возможно, массив из одного значения). Условие считается выполненным, если одно из значений в массиве *data* имеется в массиве значений атрибута.

Если тип значения атрибута не соответствует указанному фильтру (для операций сравнения типу поля *data*), условие считается не выполненным. Таким образом, наличие противоречивых фильтров, например, указание для одного атрибута одновременно фильтра **contains one of** и любого другого фильтра, будет приводить к пустому результату.  
Если поле *sort* указано, оно содержит список атрибутов с направлением сортировки. Сортировка всегда производится в порядке, указанном в запросе. Если поле *attribute\_code* отсутствует, сортировка производится по порядковому номеру кода объекта в **источнике**. Атрибуты, указанные в условиях сортировки, могут быть не указаны в поле *attributes* и, таким образом, могут не попасть в ответ.  
Допустимые типы сортировок:

* **asc** — по возрастанию значения.
* **desc** — по убыванию значения.

**data**:

	{
		"etag": "<метка, соответствующая текущему состоянию указанных атрибутов запрошенных объектов, их действий и/или шаблонов>",
		"objects": [
			{
				"code": "<код объекта>",
				"attributes": {
					"<код атрибута>": {
						"name": "<имя атрибута>",
						"value": <значение атрибута>,
						"value_description": "<описание значения атрибута>",
						"hidden": true
					},
					...
				},
				"actions": {
					"<код действия для шаблона>": {
						"code": "<код действия>",
						"name": "<имя действия для отображения>",
						"type": "<код типа действия>",
						"disabled": true,
						"warning": "<текст предупреждения>",
						"params": <значение>,
						"user_params": [
							{
								"code": "<код пользовательского параметра>",
								"type": "<тип параметра>",
								"data": <специфические для типа параметра данные>,
								"description": "<описание назначения параметра, вводимого пользователем при выполнении действия>",
								"default_value": <значение параметра по умолчанию>,
								"min_value_count": <минимальное количество значений в параметре>,
								"max_value_count": <максимальное количество значений в параметре>
							},
							...
						]
					},
					...
				},
				"template": {
					"groups": [
						{
							"name": "<имя группы для отображения>",
							"attributes": [],
							"actions": []
						},
						...
					]
				}
			}
		]
	}
Поле *etag* не может использоваться в запросах с другими параметрами.  
Поле *attributes* может отсутствовать в случае, если у объекта нет доступных объекту пользователя атрибутов (вообще или среди перечисленных в поле *attributes* запроса).  
Код атрибута не должен отображаться клиентом и может использоваться только для кастомизации.  
Имя атрибута может отсутствовать.  
Значение поля *value* не должно отображаться клиентом и может использоваться только для кастомизации, за исключением случая, когда отсутствует поле *value\_description* и значение является числом, строкой или массивом чисел или строк.  
Когда поле *hidden* присутствует, оно всегда равно `true`. Такие атрибуты не должны отображаться клиентом и могут использоваться только для кастомизации (например, для определения шаблона на основе типа отображаемого объекта).  
Поле *actions* отсутствует, если действий нет или если в запросе было передано поле *get\_actions* со значением `false`.  
Поле *type* нужно только для кастомизации на стороне клиента.  
Если поле *disabled* отсутствует, то действие можно выполнять. В противном случае значение всегда равно `true`, а поля *warning*, *params* и *user\_params* отсутствуют.  
Если поле *warning* присутствует, то перед непосредственным применением действия пользователю необходимо показать предупреждение и спросить, уверен ли он в том, что действительно хочет выполнить это действие.  
Поле *params* **не** разбирается клиентом и передаётся в неизменном виде в функцию *make\_action*.  
Поле *user\_params* содержит параметры, значения которых должны быть заданы пользователем. Если поле отсутствует, действие не требует ввода параметров. Если поле *default\_value* присутствует, оно содержит значение (или значения) по умолчанию, которые пользователь может изменить. Если поле *min\_value\_count* отсутствует, то считается, что оно равно `0` (параметр действия не является обязательным). Если поле присутствует, то оно содержит положительное число минимально допустимого количества значений параметра. Если поле *max\_value\_count* отсутствует, то максимальное количество значений параметра не ограничено. Если поле присутствует, то оно содержит положительное число максимально допустимого количества значений параметра, большее либо равное *min\_value\_count*.  
Известные типы параметров:

* **integer**: *data* может отсутствовать. Если присутствует, то содержит объект, в котором могут присутствовать ограничения на значение передаваемого числа в полях *min\_value* и *max\_value*.
* **float**: *data* может отсутствовать. Если присутствует, то содержит объект, в котором могут присутствовать ограничения на значение передаваемого числа в полях *min\_value* и *max\_value*.
* **string**: *data* может отсутствовать. Если присутствует, то содержит объект, в котором могут присутствовать ограничения на размер передаваемой строки в полях *min\_length* и *max\_length*, а также поле *multiline* со значением *true* для случаев, когда допускается ввод текста из нескольких строк.
* **objects**: *data* содержит объект с полями *object\_code* и *attribute\_code* (код объекта и код его атрибута, в котором хранятся коды объектов, из которых нужно выбрать один или несколько в качестве значения параметра). Для отображения в списке нужно использовать атрибут *name* объектов списка.

Поле *template* отсутствует, если шаблон для объекта не найден или в запросе было поле *get\_templates* со значением `false`. Поле содержит описание отображения объекта, которое используется в случае, когда клиент не использует свой шаблон для данного объекта. В заголовке отображается содержимое атрибута *name*. Клиент должен корректно обрабатывать ситуацию, когда атрибут *name* отсутствует. Остальные атрибуты разбиваются на группы. Каждая группа имеет заголовок, затем отображаются атрибуты в порядке следования их кодов в поле *attributes*, затем идут действия группы в порядке следования их кодов в поле *actions*. Поля *attributes* и *actions* могут отсутствовать. Если поле *name* группы отсутствует, группа не имеет заголовка. Если клиент не использует для объекта свой шаблон и стандартный шаблон не найден, в заголовок выносится атрибут *name*, остальные атрибуты отображаются в порядке лексикографической сортировки их кодов, а в самом конце отображаются действия (тоже в порядке лексикографической сортировки кодов). Шаблон не содержит действий, если в запросе было передано поле *get\_actions* со значением `false`, а также не ссылается на отсутствующие или отфильтрованные атрибуты. Группы не возвращаются, если в результате фильтрации атрибутов или исключения действий они не содержат действий и атрибутов.  
Если используется шаблон, возвращённый с сервера, то атрибуты и действия, не перечисленные в шаблоне, не должны отображаться.

## make\_action
Выполнение действия.

**params**:

	{
		"user_object_code": "<код объекта, от имени которого выполняется функция>",
		"action_code": "<код действия>",
		"params": {},
		"user_params": {
			"<код пользовательского параметра>": <значение пользовательского параметра>,
			...
		}
	}
Значение пользовательского параметра содержит элемент или массив (в случае нескольких значений). JSON-тип элемента (элементов массива) зависит от типа действия: `number` для **integer** или **float**, `string` для других типов.

**data**:

	null | {}
Если поле *data* не равно `null`, то значение полностью совпадает с ответом функции *get\_objects* (в ответе всегда будет только один объект). Клиент должен отобразить возвращённый объект. Если возвращается тот же объект, что отображался до осуществления действия, то клиент должен попытаться отобразить на экране те же атрибуты в тех же местах, где они отображались до выполнения действия.

# Функции для администратора
Будут добавлены позже.

# FAQ
* Как будет происходить аутентификация, если у нас нет такой функции?  
Есть два способа. Первый — попробовать получить специальный объект (например, просканировав QR-код), после чего для значения, указанного в поле *client*, будет сохранена привязка к пользователю. Второй — в одном из объектов, доступных анонимному пользователю, будет действие, принимающее авторизационный код.

* Что должно быть в QR-кодах?  
Предлагается хранить только код объекта вместо полноценной ссылки. Это позволит минимизировать объём данных и упростить QR-код, а более простые QR-коды легче распознаются.

* Как отображать список для выбора объекта/объектов, необходимых для заполнения пользовательского параметра действия?  
В общем случае при заполнении такого параметра нужно показывать пользователю фильтр по атрибуту *name*, отправлять запрос при изменении поля на получение ограниченного количества объектов с параметром `"attributes": ["name"]` и сортировкой по атрибуту *name* и показывать получаемые результаты. После выбора пользователем одного из отображаемых объектов нужно выбирать/добавлять значение в список параметров и убирать такие объекты из списка (отправлять фильтр с типом **code not in**).  
В случае, если клиент обрабатывает действия с какими-то кодами особым образом, может иметь смысл как получать список целиком, так и получать дополнительные атрибуты или сортировать по другим условиям.

* Как проверять изменение списка объектов, которыми может управлять пользователь?  
Рекомендуется после отправки любого запроса на выполнение действия, а также получение объекта или списка объектов, отправлять дополнительный запрос на проверку наличия изменений в списке объектов, которыми может управлять пользователь. Для минимизации времени ожидания рекомендуется передавать этот запрос сразу же и использовать для этого одно подключение.
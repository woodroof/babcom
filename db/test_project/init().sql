-- drop function test_project.init();

create or replace function test_project.init()
returns void
volatile
as
$$
declare
  v_type_attribute_id integer := data.get_attribute_id('type');
  v_title_attribute_id integer := data.get_attribute_id('title');
  v_subtitle_attribute_id integer := data.get_attribute_id('subtitle');
  v_is_visible_attribute_id integer := data.get_attribute_id('is_visible');
  v_description_attribute_id integer;
  v_default_actor_id integer;
  v_default_login_id integer;
begin
  insert into data.attributes(code, description, type, card_type, can_be_overridden)
  values('description', 'Текстовый блок с развёрнутым описанием очередного теста, string', 'normal', 'full', true)
  returning id into v_description_attribute_id;

  -- Создадим актора по умолчанию
  insert into data.objects(code) values('test1') returning id into v_default_actor_id;
  insert into data.attribute_values(object_id, attribute_id, value) values
  (v_default_actor_id, v_type_attribute_id, jsonb '"test"'),
  (v_default_actor_id, v_title_attribute_id, jsonb '"Тест 1"'),
  (v_default_actor_id, v_subtitle_attribute_id, jsonb '"Базовые проверки"'),
  (v_default_actor_id, v_is_visible_attribute_id, jsonb 'true'),
  (
    v_default_actor_id,
    v_description_attribute_id,
    to_jsonb(
      E'Первый тест:\n' ||
      E'— Этот объект должен был сразу показаться на старте приложения.\n' ||
      E'— Вверху отображается заголовок "Тест 1" и подзаголовок "Базовые проверки".\n' ||
      E'— В этом тексте каждый пункт находится на своей строке.\n' ||
      E'— В этой строке есть оформление: *жирный* _наклонный_ ~зачёркнутый~.\n' ||
      E'— В этой строке звёздочки и подчёркивания выводятся как есть, т.к. стили пересекаются: *а _б* в_.\n' ||
      E'— В этой строке звёздочки и подчёркивания выводятся как есть, т.к. нет символа-разделителя между стилями: *а*_б_.\n' ||
      E'— В меню пусто.\n' ||
      E'— Никаких уведомлений нет.\n' ||
      E'— В списке акторов один объект с заголовком "Тест 1" и подзаголовоком "Базовые проверки".\n' ||
      E'— Приложение само выбрало актора, т.к. нет смысла показывать список из одного элемента на старте приложения.\n' ||
      E'— Есть ровно одна группа без заголовка и ровно один атрибут без имени, действий нет.\n' ||
      E'— Объект не является списком.\n' ||
      E'— В этой строке есть ссылка со схемой babcom, ведущая на следующий тест: [ссылка](babcom:test2).')
  );

  insert into data.logins(code) values('default_login') returning id into v_default_login_id;
  insert into data.login_actors(login_id, actor_id) values(v_default_login_id, v_default_actor_id);

  insert into data.params(code, value, description) values
  ('default_login_id', to_jsonb(v_default_login_id), 'Идентификатор логина по умолчанию'),
  (
    'template',
    jsonb
    '{
      "groups": [
        {
          "attributes": ["description"]
        }
      ]
    }',
    'Шаблон'
  );

  -- Тест 2: три подписки: меню, уведомления и текущий объект. Предыдущего объекта в подписках быть не должно.
  -- Проверяем группы, имена групп, расположение по шаблону
  -- По действию генерируем изменение меню (добавляем ссылку для перехода на третий тест) и текущего объекта (изменяем поля, добавляем кнопки)

  -- Тест 3
  -- Тест должен был открыться в основной области
  -- В меню теперь кнопка с подтверждением и заблокированная кнопка в двух разных группах
  -- Кнопка отправит уведомление, по открытию которого сервер изменит список доступных акторов.
  -- Приложение должно выбрать актор автоматически, т.к. список состоит из одного объекта.
  -- По документации приложение должно выставить новый актор и снова запросить текущий объект (уведомление), которое уже перенаправит на тест 4.

  -- Тест 4
  -- Кнопка с результатом do_nothing. Также пришлём diff, заменяющий кнопку.
  -- Пришлём diff, добавляющий много групп и атрибутов и одну новую кнопку. Эта кнопка удалит свою группу - должны остаться на месте.
  -- В следующей группе кнопка с параметрами и ограничениями на них. Пришлём переход на следующий тест.

  -- Тест 5
  -- Не должен оставаться в истории! Ссылка на тест 6.

  -- Тест 6
  -- Одна кнопка, которая пришлёт возврат по истории к тесту 4, который уже будет тестом 7.

  -- Тест 7
  -- Список, возвратили всего десять объектов, но при достижении конца должны запросить ещё - вернётся ещё один.
  -- В последнем есть кнопка, которая изменит этот объект (уберёт кнопку) и один из предыдущих (добавит кнопку), а также удалит один предыдущий и добавит два - должны остаться на месте (в конце списка)
  -- По кнопке снова удаляем предыдущий и меняем текущий - должны остаться на месте. Получается, что при выполнении действия у элемента мы знаем, что этот элемент "активный".
  -- Все элементы списка всегда перенаправляют на сам тест.

  -- Тест 8
  -- Список из одного элемента, а потом возвращается ещё один, а потом - ещё один. И всё.
  -- Проверяем, что клиент нормально обрабатывает, когда вся страница видна, а также когда возвращённые всё равно не закрывают всё.
  -- Последний элемент - тест 9, остальные перенаправляют на 8.

  -- Тесты на смахивание уведомлений, списки в меню
end;
$$
language 'plpgsql';
